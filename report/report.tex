 \documentclass{CRPITStyle} 
%\usepackage{epsfig}   % Packages to use if you wish
%\usepackage{lscape}   %
\usepackage{listings}
\lstset{language=Java,
 captionpos=b,
 tabsize=3,
 frame=lines,
% keywordstyle=\color{blue},
 commentstyle=\color{darkgreen},
 stringstyle=\color{red},
 numbers=left,
 numberstyle=\tiny,
 numbersep=5pt,
 breaklines=true,
 showstringspaces=false,
 basicstyle=\footnotesize,
 emph={label}
}

\usepackage[authoryear]{natbib}
\renewcommand{\cite}{\citep}
\pagestyle{empty}
\thispagestyle{empty}

\begin{document}

\title{DBSCAN Visualisation Report}
\author{Jonathan Mackenzie}
\affiliation{$^1$ School of Computer Science, Engineering and Mathematics \\
Flinders University of South Australia, \\
PO Box 2100, Adelaide, South Australia 5001, \\
Email:~{\tt jonathan.mackenzie@flinders.edu.au}\\[.1in]}

\maketitle

\begin{abstract}
This report describes my Java implementation of the DBSCAN algorithm and associated visualisation. It describes the development process, the justification of data-structures used and explanation of features.
\end{abstract}
\vspace{.1in}

\section{Introduction}
The Density-Based Spatial Clustering of Applications with Noise (DBSCAN) algorithm was originally proposed by \cite{Ester96adensity-based} and has applications where neighbours of a spatial object need to be found quickly such as graphical information systems (GIS) and collision detection in games and physics simulations. In this project, I use quadtrees as a backing data structure for calculating clusters using the DBSCAN algorithm. Other data structures such as KD-tree were considered but Quadtree was chosen because of it's simplicity.

\section{Usage}
To run the program, simply run the executable jar attached. The application has 2 main areas in the GUI: the visualisation and the configuration. The visualisation displays the results. To configure the run of the algorithm, set minpts and epsilon or push the "calculate parameters" button to have them calculated for you. The load file button will prompt the user to select a file of whitespace separated integers, with 2 integers per line to indicate a point in space. The export clusters button will prompt the user to select an output location for clustering results. The recalculate clusters button can be used to recalculate the clustering after changing minpts (but not epsilon). This does not require recalculation of neighbours. Start will run the neighbouring and then clustering algorithms. The progress bar displays the progress. The text area displays a log of the applications workings.

\section{Application}
\subsection{Features}
The features of the application are:
\begin{enumerate}
\item Visualisation of clusters and noise
\item Exporting of clustering results
\item Visualisation of algorithm progress results
\item User specified parameters for minpts and epsilon
\item Optional automatic calculation of minpts and epsilon parameters 
\item Iterative cluster calculation (useful when making small tweaks to minpts, avoiding multiple neighbouring calculations). Made possible by storing the neighbours of each point as a member of that point. This requires $O(n^2)$ memory. Note do a benchmark for retrieving neighbours at each run.
\end{enumerate}

\subsection{Internals}
Originally, the application was written in Python (with limited features compared to the Java implementation), but this proved too slow when calculating the neighbours of points using the method described . When developing the DBSCAN algorithm, 

Java was chosen as the development language because it allowedd the rapid development of the GUI using a GUI builder and has sufficient runtime performace compared to python. Interally, the data-points are stored in a QuadTree; a data-structure that provides $O(\log n)$ neighbour searching, $O(n)$ memory and $O(n)$ generation. The na\"{\i}ve method of calculating the distance between all points, as described below requires $O(n^2)$ time, but with a simple optimisation we can achieve $O(\frac{n^2 -n}{2})$

\begin{lstlisting}[caption=A na\"{\i}ve implementation for calculating which points are neighbours]
public void findNeighbours(ArrayList<Point> points, int epsilon) {
    for (int i = 0; i < points.size(); i++) {
        for (int j = i + 1; j < points.size(); j++) {
            Point p = points.get(i), q = points.get(j);
            if (p.distance(q) <= epsilon) {
                p.addNeighbour(q);
                q.addNeighbour(p);
            }
        }
    }
}

\end{lstlisting}
\subsection{Quadtree}
The quadtree \citet{Samet:1984:QRH:356924.356930} is a hierarchical data structure that stores data by partitioning each level into four quadrants. Each node in the tree has four subregions, similar to the quadrants of a compass, where points are stored in relation to the parent node. This makes searching and 

\bibliographystyle{agsm}  
\bibliography{references}
\end{document}

